{"version":3,"file":"Leaflet.canvaslabel.js","mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;;;;;;;ACVa;;AAEb;AACA,sBAAsB;;AAEtB,kBAAkB,mBAAO,CAAC,CAAa;;AAEvC;AACA;;AAEA,8CAA8C;AAC9C;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,oDAAoD,SAAS;;AAE7D;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,oDAAoD,SAAS;;AAE7D;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA,+CAA+C,SAAS;AACxD;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,UAAU;AACV;AACA;;AAEA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;;AAEA,6BAA6B;AAC7B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kEAAkE;AAClE;AACA;AACA;AACA;AACA;;AAEA,cAAc,mBAAmB;AACjC;AACA;AACA;;AAEA,cAAc,kBAAkB;AAChC;;AAEA;AACA,KAAK;;AAEL,8BAA8B,cAAc;;AAE5C;AACA;;AAEA,0BAA0B,mBAAmB;;AAE7C;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;;AAEA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA,uBAAuB,YAAY;;AAEnC;;AAEA;;AAEA,wBAAwB,aAAa;;AAErC;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,KAAK;;AAEL;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA,oDAAoD,SAAS;AAC7D;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,mCAAmC;AACnC;AACA;AACA;AACA;AACA,cAAc;AACd;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;;AAEA;;AAEA,oBAAoB,YAAY;AAChC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,oBAAoB,WAAW;AAC/B;AACA;AACA;AACA;;AAEA,4BAA4B,QAAQ;AACpC;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA,4BAA4B,QAAQ;AACpC;AACA;AACA,KAAK;;AAEL;AACA;AACA,gDAAgD,QAAQ;AACxD;AACA;AACA;AACA;;AAEA,kBAAkB;;AAElB,cAAc;AACd;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;;AAEA,gDAAgD;;AAEhD;AACA;;AAEA;AACA,qBAAqB;AACrB;AACA;AACA,yCAAyC;AACzC;AACA;;AAEA;AACA;;AAEA,oBAAoB,kBAAkB;AACtC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,2BAA2B,OAAO;AAClC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iCAAiC;AACjC,iCAAiC;;AAEjC,yBAAyB;AACzB,yBAAyB;;AAEzB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;;;;;;ACjjBA;AACA,CAAC,KAA4D;AAC7D,CAAC,CACgC;AACjC,CAAC,sBAAsB;;AAEvB;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,CAAC;;;;;;UC9DD;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;WACA;WACA;WACA;WACA;WACA,iCAAiC,WAAW;WAC5C;WACA;;;;;WCPA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;;;;;;;;;;;ACN0B,CAAC;AAC3B;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,mCAAmC,8CAAK;AACxC,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,OAAO;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,uBAAuB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,6BAA6B;AAC7B,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,UAAU;AACV;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,CAAC;AACD;AACO;AACP;AACA,CAAC","sources":["webpack://@panzhiyue/leaflet-canvaslabel/webpack/universalModuleDefinition","webpack://@panzhiyue/leaflet-canvaslabel/./node_modules/rbush/index.js","webpack://@panzhiyue/leaflet-canvaslabel/./node_modules/quickselect/quickselect.js","webpack://@panzhiyue/leaflet-canvaslabel/webpack/bootstrap","webpack://@panzhiyue/leaflet-canvaslabel/webpack/runtime/compat get default export","webpack://@panzhiyue/leaflet-canvaslabel/webpack/runtime/define property getters","webpack://@panzhiyue/leaflet-canvaslabel/webpack/runtime/hasOwnProperty shorthand","webpack://@panzhiyue/leaflet-canvaslabel/webpack/runtime/make namespace object","webpack://@panzhiyue/leaflet-canvaslabel/./src/leaflet.canvaslabel.js"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse {\n\t\tvar a = factory();\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(self, function() {\nreturn ","'use strict';\n\nmodule.exports = rbush;\nmodule.exports.default = rbush;\n\nvar quickselect = require('quickselect');\n\nfunction rbush(maxEntries, format) {\n    if (!(this instanceof rbush)) return new rbush(maxEntries, format);\n\n    // max entries in a node is 9 by default; min node fill is 40% for best performance\n    this._maxEntries = Math.max(4, maxEntries || 9);\n    this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));\n\n    if (format) {\n        this._initFormat(format);\n    }\n\n    this.clear();\n}\n\nrbush.prototype = {\n\n    all: function () {\n        return this._all(this.data, []);\n    },\n\n    search: function (bbox) {\n\n        var node = this.data,\n            result = [],\n            toBBox = this.toBBox;\n\n        if (!intersects(bbox, node)) return result;\n\n        var nodesToSearch = [],\n            i, len, child, childBBox;\n\n        while (node) {\n            for (i = 0, len = node.children.length; i < len; i++) {\n\n                child = node.children[i];\n                childBBox = node.leaf ? toBBox(child) : child;\n\n                if (intersects(bbox, childBBox)) {\n                    if (node.leaf) result.push(child);\n                    else if (contains(bbox, childBBox)) this._all(child, result);\n                    else nodesToSearch.push(child);\n                }\n            }\n            node = nodesToSearch.pop();\n        }\n\n        return result;\n    },\n\n    collides: function (bbox) {\n\n        var node = this.data,\n            toBBox = this.toBBox;\n\n        if (!intersects(bbox, node)) return false;\n\n        var nodesToSearch = [],\n            i, len, child, childBBox;\n\n        while (node) {\n            for (i = 0, len = node.children.length; i < len; i++) {\n\n                child = node.children[i];\n                childBBox = node.leaf ? toBBox(child) : child;\n\n                if (intersects(bbox, childBBox)) {\n                    if (node.leaf || contains(bbox, childBBox)) return true;\n                    nodesToSearch.push(child);\n                }\n            }\n            node = nodesToSearch.pop();\n        }\n\n        return false;\n    },\n\n    load: function (data) {\n        if (!(data && data.length)) return this;\n\n        if (data.length < this._minEntries) {\n            for (var i = 0, len = data.length; i < len; i++) {\n                this.insert(data[i]);\n            }\n            return this;\n        }\n\n        // recursively build the tree with the given data from scratch using OMT algorithm\n        var node = this._build(data.slice(), 0, data.length - 1, 0);\n\n        if (!this.data.children.length) {\n            // save as is if tree is empty\n            this.data = node;\n\n        } else if (this.data.height === node.height) {\n            // split root if trees have the same height\n            this._splitRoot(this.data, node);\n\n        } else {\n            if (this.data.height < node.height) {\n                // swap trees if inserted one is bigger\n                var tmpNode = this.data;\n                this.data = node;\n                node = tmpNode;\n            }\n\n            // insert the small tree into the large tree at appropriate level\n            this._insert(node, this.data.height - node.height - 1, true);\n        }\n\n        return this;\n    },\n\n    insert: function (item) {\n        if (item) this._insert(item, this.data.height - 1);\n        return this;\n    },\n\n    clear: function () {\n        this.data = createNode([]);\n        return this;\n    },\n\n    remove: function (item, equalsFn) {\n        if (!item) return this;\n\n        var node = this.data,\n            bbox = this.toBBox(item),\n            path = [],\n            indexes = [],\n            i, parent, index, goingUp;\n\n        // depth-first iterative tree traversal\n        while (node || path.length) {\n\n            if (!node) { // go up\n                node = path.pop();\n                parent = path[path.length - 1];\n                i = indexes.pop();\n                goingUp = true;\n            }\n\n            if (node.leaf) { // check current node\n                index = findItem(item, node.children, equalsFn);\n\n                if (index !== -1) {\n                    // item found, remove the item and condense tree upwards\n                    node.children.splice(index, 1);\n                    path.push(node);\n                    this._condense(path);\n                    return this;\n                }\n            }\n\n            if (!goingUp && !node.leaf && contains(node, bbox)) { // go down\n                path.push(node);\n                indexes.push(i);\n                i = 0;\n                parent = node;\n                node = node.children[0];\n\n            } else if (parent) { // go right\n                i++;\n                node = parent.children[i];\n                goingUp = false;\n\n            } else node = null; // nothing found\n        }\n\n        return this;\n    },\n\n    toBBox: function (item) { return item; },\n\n    compareMinX: compareNodeMinX,\n    compareMinY: compareNodeMinY,\n\n    toJSON: function () { return this.data; },\n\n    fromJSON: function (data) {\n        this.data = data;\n        return this;\n    },\n\n    _all: function (node, result) {\n        var nodesToSearch = [];\n        while (node) {\n            if (node.leaf) result.push.apply(result, node.children);\n            else nodesToSearch.push.apply(nodesToSearch, node.children);\n\n            node = nodesToSearch.pop();\n        }\n        return result;\n    },\n\n    _build: function (items, left, right, height) {\n\n        var N = right - left + 1,\n            M = this._maxEntries,\n            node;\n\n        if (N <= M) {\n            // reached leaf level; return leaf\n            node = createNode(items.slice(left, right + 1));\n            calcBBox(node, this.toBBox);\n            return node;\n        }\n\n        if (!height) {\n            // target height of the bulk-loaded tree\n            height = Math.ceil(Math.log(N) / Math.log(M));\n\n            // target number of root entries to maximize storage utilization\n            M = Math.ceil(N / Math.pow(M, height - 1));\n        }\n\n        node = createNode([]);\n        node.leaf = false;\n        node.height = height;\n\n        // split the items into M mostly square tiles\n\n        var N2 = Math.ceil(N / M),\n            N1 = N2 * Math.ceil(Math.sqrt(M)),\n            i, j, right2, right3;\n\n        multiSelect(items, left, right, N1, this.compareMinX);\n\n        for (i = left; i <= right; i += N1) {\n\n            right2 = Math.min(i + N1 - 1, right);\n\n            multiSelect(items, i, right2, N2, this.compareMinY);\n\n            for (j = i; j <= right2; j += N2) {\n\n                right3 = Math.min(j + N2 - 1, right2);\n\n                // pack each entry recursively\n                node.children.push(this._build(items, j, right3, height - 1));\n            }\n        }\n\n        calcBBox(node, this.toBBox);\n\n        return node;\n    },\n\n    _chooseSubtree: function (bbox, node, level, path) {\n\n        var i, len, child, targetNode, area, enlargement, minArea, minEnlargement;\n\n        while (true) {\n            path.push(node);\n\n            if (node.leaf || path.length - 1 === level) break;\n\n            minArea = minEnlargement = Infinity;\n\n            for (i = 0, len = node.children.length; i < len; i++) {\n                child = node.children[i];\n                area = bboxArea(child);\n                enlargement = enlargedArea(bbox, child) - area;\n\n                // choose entry with the least area enlargement\n                if (enlargement < minEnlargement) {\n                    minEnlargement = enlargement;\n                    minArea = area < minArea ? area : minArea;\n                    targetNode = child;\n\n                } else if (enlargement === minEnlargement) {\n                    // otherwise choose one with the smallest area\n                    if (area < minArea) {\n                        minArea = area;\n                        targetNode = child;\n                    }\n                }\n            }\n\n            node = targetNode || node.children[0];\n        }\n\n        return node;\n    },\n\n    _insert: function (item, level, isNode) {\n\n        var toBBox = this.toBBox,\n            bbox = isNode ? item : toBBox(item),\n            insertPath = [];\n\n        // find the best node for accommodating the item, saving all nodes along the path too\n        var node = this._chooseSubtree(bbox, this.data, level, insertPath);\n\n        // put the item into the node\n        node.children.push(item);\n        extend(node, bbox);\n\n        // split on node overflow; propagate upwards if necessary\n        while (level >= 0) {\n            if (insertPath[level].children.length > this._maxEntries) {\n                this._split(insertPath, level);\n                level--;\n            } else break;\n        }\n\n        // adjust bboxes along the insertion path\n        this._adjustParentBBoxes(bbox, insertPath, level);\n    },\n\n    // split overflowed node into two\n    _split: function (insertPath, level) {\n\n        var node = insertPath[level],\n            M = node.children.length,\n            m = this._minEntries;\n\n        this._chooseSplitAxis(node, m, M);\n\n        var splitIndex = this._chooseSplitIndex(node, m, M);\n\n        var newNode = createNode(node.children.splice(splitIndex, node.children.length - splitIndex));\n        newNode.height = node.height;\n        newNode.leaf = node.leaf;\n\n        calcBBox(node, this.toBBox);\n        calcBBox(newNode, this.toBBox);\n\n        if (level) insertPath[level - 1].children.push(newNode);\n        else this._splitRoot(node, newNode);\n    },\n\n    _splitRoot: function (node, newNode) {\n        // split root node\n        this.data = createNode([node, newNode]);\n        this.data.height = node.height + 1;\n        this.data.leaf = false;\n        calcBBox(this.data, this.toBBox);\n    },\n\n    _chooseSplitIndex: function (node, m, M) {\n\n        var i, bbox1, bbox2, overlap, area, minOverlap, minArea, index;\n\n        minOverlap = minArea = Infinity;\n\n        for (i = m; i <= M - m; i++) {\n            bbox1 = distBBox(node, 0, i, this.toBBox);\n            bbox2 = distBBox(node, i, M, this.toBBox);\n\n            overlap = intersectionArea(bbox1, bbox2);\n            area = bboxArea(bbox1) + bboxArea(bbox2);\n\n            // choose distribution with minimum overlap\n            if (overlap < minOverlap) {\n                minOverlap = overlap;\n                index = i;\n\n                minArea = area < minArea ? area : minArea;\n\n            } else if (overlap === minOverlap) {\n                // otherwise choose distribution with minimum area\n                if (area < minArea) {\n                    minArea = area;\n                    index = i;\n                }\n            }\n        }\n\n        return index;\n    },\n\n    // sorts node children by the best axis for split\n    _chooseSplitAxis: function (node, m, M) {\n\n        var compareMinX = node.leaf ? this.compareMinX : compareNodeMinX,\n            compareMinY = node.leaf ? this.compareMinY : compareNodeMinY,\n            xMargin = this._allDistMargin(node, m, M, compareMinX),\n            yMargin = this._allDistMargin(node, m, M, compareMinY);\n\n        // if total distributions margin value is minimal for x, sort by minX,\n        // otherwise it's already sorted by minY\n        if (xMargin < yMargin) node.children.sort(compareMinX);\n    },\n\n    // total margin of all possible split distributions where each node is at least m full\n    _allDistMargin: function (node, m, M, compare) {\n\n        node.children.sort(compare);\n\n        var toBBox = this.toBBox,\n            leftBBox = distBBox(node, 0, m, toBBox),\n            rightBBox = distBBox(node, M - m, M, toBBox),\n            margin = bboxMargin(leftBBox) + bboxMargin(rightBBox),\n            i, child;\n\n        for (i = m; i < M - m; i++) {\n            child = node.children[i];\n            extend(leftBBox, node.leaf ? toBBox(child) : child);\n            margin += bboxMargin(leftBBox);\n        }\n\n        for (i = M - m - 1; i >= m; i--) {\n            child = node.children[i];\n            extend(rightBBox, node.leaf ? toBBox(child) : child);\n            margin += bboxMargin(rightBBox);\n        }\n\n        return margin;\n    },\n\n    _adjustParentBBoxes: function (bbox, path, level) {\n        // adjust bboxes along the given tree path\n        for (var i = level; i >= 0; i--) {\n            extend(path[i], bbox);\n        }\n    },\n\n    _condense: function (path) {\n        // go through the path, removing empty nodes and updating bboxes\n        for (var i = path.length - 1, siblings; i >= 0; i--) {\n            if (path[i].children.length === 0) {\n                if (i > 0) {\n                    siblings = path[i - 1].children;\n                    siblings.splice(siblings.indexOf(path[i]), 1);\n\n                } else this.clear();\n\n            } else calcBBox(path[i], this.toBBox);\n        }\n    },\n\n    _initFormat: function (format) {\n        // data format (minX, minY, maxX, maxY accessors)\n\n        // uses eval-type function compilation instead of just accepting a toBBox function\n        // because the algorithms are very sensitive to sorting functions performance,\n        // so they should be dead simple and without inner calls\n\n        var compareArr = ['return a', ' - b', ';'];\n\n        this.compareMinX = new Function('a', 'b', compareArr.join(format[0]));\n        this.compareMinY = new Function('a', 'b', compareArr.join(format[1]));\n\n        this.toBBox = new Function('a',\n            'return {minX: a' + format[0] +\n            ', minY: a' + format[1] +\n            ', maxX: a' + format[2] +\n            ', maxY: a' + format[3] + '};');\n    }\n};\n\nfunction findItem(item, items, equalsFn) {\n    if (!equalsFn) return items.indexOf(item);\n\n    for (var i = 0; i < items.length; i++) {\n        if (equalsFn(item, items[i])) return i;\n    }\n    return -1;\n}\n\n// calculate node's bbox from bboxes of its children\nfunction calcBBox(node, toBBox) {\n    distBBox(node, 0, node.children.length, toBBox, node);\n}\n\n// min bounding rectangle of node children from k to p-1\nfunction distBBox(node, k, p, toBBox, destNode) {\n    if (!destNode) destNode = createNode(null);\n    destNode.minX = Infinity;\n    destNode.minY = Infinity;\n    destNode.maxX = -Infinity;\n    destNode.maxY = -Infinity;\n\n    for (var i = k, child; i < p; i++) {\n        child = node.children[i];\n        extend(destNode, node.leaf ? toBBox(child) : child);\n    }\n\n    return destNode;\n}\n\nfunction extend(a, b) {\n    a.minX = Math.min(a.minX, b.minX);\n    a.minY = Math.min(a.minY, b.minY);\n    a.maxX = Math.max(a.maxX, b.maxX);\n    a.maxY = Math.max(a.maxY, b.maxY);\n    return a;\n}\n\nfunction compareNodeMinX(a, b) { return a.minX - b.minX; }\nfunction compareNodeMinY(a, b) { return a.minY - b.minY; }\n\nfunction bboxArea(a)   { return (a.maxX - a.minX) * (a.maxY - a.minY); }\nfunction bboxMargin(a) { return (a.maxX - a.minX) + (a.maxY - a.minY); }\n\nfunction enlargedArea(a, b) {\n    return (Math.max(b.maxX, a.maxX) - Math.min(b.minX, a.minX)) *\n           (Math.max(b.maxY, a.maxY) - Math.min(b.minY, a.minY));\n}\n\nfunction intersectionArea(a, b) {\n    var minX = Math.max(a.minX, b.minX),\n        minY = Math.max(a.minY, b.minY),\n        maxX = Math.min(a.maxX, b.maxX),\n        maxY = Math.min(a.maxY, b.maxY);\n\n    return Math.max(0, maxX - minX) *\n           Math.max(0, maxY - minY);\n}\n\nfunction contains(a, b) {\n    return a.minX <= b.minX &&\n           a.minY <= b.minY &&\n           b.maxX <= a.maxX &&\n           b.maxY <= a.maxY;\n}\n\nfunction intersects(a, b) {\n    return b.minX <= a.maxX &&\n           b.minY <= a.maxY &&\n           b.maxX >= a.minX &&\n           b.maxY >= a.minY;\n}\n\nfunction createNode(children) {\n    return {\n        children: children,\n        height: 1,\n        leaf: true,\n        minX: Infinity,\n        minY: Infinity,\n        maxX: -Infinity,\n        maxY: -Infinity\n    };\n}\n\n// sort an array so that items come in groups of n unsorted items, with groups sorted between each other;\n// combines selection algorithm with binary divide & conquer approach\n\nfunction multiSelect(arr, left, right, n, compare) {\n    var stack = [left, right],\n        mid;\n\n    while (stack.length) {\n        right = stack.pop();\n        left = stack.pop();\n\n        if (right - left <= n) continue;\n\n        mid = left + Math.ceil((right - left) / n / 2) * n;\n        quickselect(arr, mid, left, right, compare);\n\n        stack.push(left, mid, mid, right);\n    }\n}\n","(function (global, factory) {\n\ttypeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n\ttypeof define === 'function' && define.amd ? define(factory) :\n\t(global.quickselect = factory());\n}(this, (function () { 'use strict';\n\nfunction quickselect(arr, k, left, right, compare) {\n    quickselectStep(arr, k, left || 0, right || (arr.length - 1), compare || defaultCompare);\n}\n\nfunction quickselectStep(arr, k, left, right, compare) {\n\n    while (right > left) {\n        if (right - left > 600) {\n            var n = right - left + 1;\n            var m = k - left + 1;\n            var z = Math.log(n);\n            var s = 0.5 * Math.exp(2 * z / 3);\n            var sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);\n            var newLeft = Math.max(left, Math.floor(k - m * s / n + sd));\n            var newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));\n            quickselectStep(arr, k, newLeft, newRight, compare);\n        }\n\n        var t = arr[k];\n        var i = left;\n        var j = right;\n\n        swap(arr, left, k);\n        if (compare(arr[right], t) > 0) swap(arr, left, right);\n\n        while (i < j) {\n            swap(arr, i, j);\n            i++;\n            j--;\n            while (compare(arr[i], t) < 0) i++;\n            while (compare(arr[j], t) > 0) j--;\n        }\n\n        if (compare(arr[left], t) === 0) swap(arr, left, j);\n        else {\n            j++;\n            swap(arr, j, right);\n        }\n\n        if (j <= k) left = j + 1;\n        if (k <= j) right = j - 1;\n    }\n}\n\nfunction swap(arr, i, j) {\n    var tmp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = tmp;\n}\n\nfunction defaultCompare(a, b) {\n    return a < b ? -1 : a > b ? 1 : 0;\n}\n\nreturn quickselect;\n\n})));\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import rbush from \"rbush\"; //https://www.5axxw.com/wiki/content/7wjc4t\r\n\r\nexport var CanvasLabel = (L.CanvasLabel = L.Canvas.extend({\r\n    options: {\r\n        defaultLabelStyle: {\r\n            offsetX: 0, //横坐标偏移(像素)\r\n            offsetY: 0, //纵坐标偏移(像素)\r\n            scale: 1, //放大比例\r\n            rotation: 0, //旋转角度（弧度），可能会导致碰撞检测不准确\r\n            text: null, //标注文本内容\r\n            minZoom: null, //最小显示级别\r\n            maxZoom: null, //最大显示级别\r\n            collisionFlg: true, //碰撞检测\r\n            center: null, //标注位置，默认为null,会自动计算几何中心\r\n            zIndex: 0, //排序\r\n            defaultHeight: 20, //文本高度,无法自动计算,所以直接传参手动调整\r\n\r\n            //文本样式,具体值请参考[canvas](https://www.runoob.com/tags/ref-canvas.html)\r\n            font: \"10px sans-serif\",\r\n            fillStyle: \"rgba(0,0,0,1)\",\r\n            lineCap: \"round\",\r\n            lineDash: [],\r\n            lineDashOffset: 0,\r\n            lineJoin: \"round\",\r\n            strokeStyle: \"rgba(0,0,0,1)\",\r\n            textAlign: \"center\",\r\n            textBaseline: \"middle\",\r\n            lineWidth: 1,\r\n        },\r\n    },\r\n    getEvents: function () {\r\n        var events = {\r\n            viewreset: this._reset,\r\n            zoom: this._onZoom,\r\n            moveend: this._update,\r\n            zoomend: this._onZoomEnd,\r\n            click: this._executeListeners,\r\n            mousemove: this._executeListeners,\r\n            mousedown: this._executeListeners,\r\n            mouseup: this._executeListeners,\r\n        };\r\n        if (this._zoomAnimated) {\r\n            events.zoomanim = this._onAnimZoom;\r\n        }\r\n        return events;\r\n    },\r\n\r\n    initialize: function (options) {\r\n        this._onClickListeners = [];\r\n        this._onHoverListeners = [];\r\n        this._onMouseDownListeners = [];\r\n        this._onMouseUpListeners = [];\r\n\r\n        options.defaultLabelStyle = options.defaultLabelStyle || {};\r\n        options.defaultLabelStyle = L.extend(\r\n            {},\r\n            this.options.defaultLabelStyle,\r\n            options.defaultLabelStyle\r\n        );\r\n        L.Canvas.prototype.initialize.call(this, options);\r\n    },\r\n\r\n    /**\r\n     * 继承L.Canvas方法\r\n     * 在刷新时保存画布当前地理位置\r\n     */\r\n    _update: function () {\r\n        this._latlngBounds = this._map.getBounds().pad(this.options.padding);\r\n\r\n        L.Canvas.prototype._update.call(this);\r\n    },\r\n\r\n    _draw: function () {\r\n        if (!this._textBounds) {\r\n            this._textBounds = new rbush();\r\n        } else {\r\n            this._textBounds.clear();\r\n        }\r\n        let drawLayers = [];\r\n\r\n        var layer,\r\n            bounds = this._redrawBounds;\r\n        this._ctx.save();\r\n        if (bounds) {\r\n            var size = bounds.getSize();\r\n            this._ctx.beginPath();\r\n            this._ctx.rect(bounds.min.x, bounds.min.y, size.x, size.y);\r\n            this._ctx.clip();\r\n        }\r\n\r\n        this._drawing = true;\r\n\r\n        for (var order = this._drawFirst; order; order = order.next) {\r\n            layer = order.layer;\r\n            if (\r\n                !bounds ||\r\n                (layer._pxBounds && layer._pxBounds.intersects(bounds))\r\n            ) {\r\n                drawLayers.push(layer);\r\n            }\r\n        }\r\n        for (let i = 0; i < drawLayers.length; i++) {\r\n            drawLayers[i]._updatePath();\r\n        }\r\n\r\n        //筛选需要绘制标注的图层\r\n        let labelLayers = drawLayers.filter(function (layer) {\r\n            return layer.options.labelStyle && layer.options.labelStyle.text;\r\n        });\r\n\r\n        //筛选不做碰撞检测的标签图层并安装zIndex排序\r\n        let notCollisionLayers = labelLayers.filter((layer) => {\r\n            var collisionFlg =\r\n                layer.options.labelStyle.collisionFlg != undefined\r\n                    ? layer.options.labelStyle.collisionFlg\r\n                    : this.options.defaultLabelStyle.collisionFlg;\r\n            return collisionFlg != true;\r\n        });\r\n        //不需要做碰撞检测的标注升序排序,zIndex值大的后绘制,会覆盖在先绘制的标注上面\r\n        notCollisionLayers\r\n            .sort((layer1, layer2) => {\r\n                let zIndex1 = layer1.options.labelStyle.zIndex\r\n                    ? layer1.options.labelStyle.zIndex\r\n                    : this.options.defaultLabelStyle.zIndex;\r\n                let zIndex2 = layer2.options.labelStyle.zIndex\r\n                    ? layer2.options.labelStyle.zIndex\r\n                    : this.options.defaultLabelStyle.zIndex;\r\n                return zIndex1 - zIndex2;\r\n            })\r\n            .forEach((layer) => {\r\n                this._updateText(this._ctx, layer);\r\n            });\r\n\r\n        //筛选需要碰撞检测的标签图层并安装zIndex排序\r\n        let collisionLayers = labelLayers.filter((layer) => {\r\n            var collisionFlg =\r\n                layer.options.labelStyle.collisionFlg != undefined\r\n                    ? layer.options.labelStyle.collisionFlg\r\n                    : this.options.defaultLabelStyle.collisionFlg;\r\n            return collisionFlg == true;\r\n        });\r\n\r\n        //需要做碰撞检测的标注降序排序,zIndex值大的优先绘制\r\n        collisionLayers\r\n            .sort((layer1, layer2) => {\r\n                let zIndex1 = layer1.options.labelStyle.zIndex\r\n                    ? layer1.options.labelStyle.zIndex\r\n                    : this.options.defaultLabelStyle.zIndex;\r\n                let zIndex2 = layer2.options.labelStyle.zIndex\r\n                    ? layer2.options.labelStyle.zIndex\r\n                    : this.options.defaultLabelStyle.zIndex;\r\n                return -zIndex1 + zIndex2;\r\n            })\r\n            .forEach((layer) => {\r\n                this._updateText(this._ctx, layer);\r\n            });\r\n\r\n        this._drawing = false;\r\n\r\n        this._ctx.restore(); // Restore state before clipping.\r\n    },\r\n\r\n    /**\r\n     * 更新文本标注\r\n     */\r\n    _updateText: function (ctx, layer) {\r\n        //没有标签样式或没有标签文本的直接退出\r\n        if (!layer.options.labelStyle || !layer.options.labelStyle.text) {\r\n            return;\r\n        }\r\n        //计算图形中心点\r\n        var latlng = L.latLng(layer.options.labelStyle.center);\r\n        if (latlng) {\r\n        } else if (layer.getLatLng) {\r\n            latlng = layer.getLatLng();\r\n        } else {\r\n            //线，面没有环的直接退出\r\n            if (layer._parts.length == 0 || layer._parts[0].length == 0) {\r\n                return;\r\n            }\r\n            latlng = layer.getCenter();\r\n        }\r\n\r\n        //图形中心点没有在可视区域内的直接退出\r\n        if (!this._latlngBounds.contains(latlng)) {\r\n            return;\r\n        }\r\n\r\n        let layerLabelStyle = layer.options.labelStyle;\r\n        let defaultLabelStyle = L.extend({}, this.options.defaultLabelStyle);\r\n        //图层标注样式是个函数\r\n        if (typeof layerLabelStyle == \"function\") {\r\n            layerLabelStyle = layerLabelStyle(layer);\r\n        }\r\n\r\n        //最终标注样式\r\n        let labelStyle = L.extend(defaultLabelStyle, layer.options.labelStyle);\r\n\r\n        //地图缩放级别小于标注最小显示级别直接退出\r\n        if (labelStyle.minZoom) {\r\n            if (this._map.getZoom() < labelStyle.minZoom) {\r\n                return;\r\n            }\r\n        }\r\n\r\n        //地图缩放级别大于标注最大显示级别直接退出\r\n        if (labelStyle.maxZoom) {\r\n            if (this._map.getZoom() > labelStyle.maxZoom) {\r\n                return;\r\n            }\r\n        }\r\n        //保持画布原本样式\r\n        ctx.save();\r\n\r\n        //设置画布样式\r\n        ctx.font = labelStyle.font;\r\n        ctx.fillStyle = labelStyle.fillStyle;\r\n        ctx.lineCap = labelStyle.lineCap;\r\n        ctx.lineDash = labelStyle.lineDash;\r\n        ctx.lineDashOffset = labelStyle.lineDashOffset;\r\n        ctx.lineJoin = labelStyle.lineJoin;\r\n        ctx.strokeStyle = labelStyle.strokeStyle;\r\n        ctx.textAlign = labelStyle.textAlign;\r\n        ctx.textBaseline = labelStyle.textBaseline;\r\n        ctx.lineWidth = labelStyle.lineWidth;\r\n\r\n        // 标注偏移\r\n        var offsetX = labelStyle.offsetX;\r\n        var offsetY = labelStyle.offsetY;\r\n        //相对于原点的相应像素坐标\r\n        var p = this._map.latLngToLayerPoint(latlng);\r\n\r\n        //计算标注像素坐标\r\n        var x = p.x + offsetX;\r\n        var y = p.y + offsetY;\r\n\r\n        //设置标注坐标为中心点(这样可以直接进行缩放与旋转而不用考虑其他因素，实现后通过还原画布不会影响其他效果)\r\n        ctx.translate(x, y);\r\n\r\n        //缩放比例不为1\r\n        if (labelStyle.scale != 1) {\r\n            ctx.scale(labelStyle.scale, labelStyle.scale);\r\n        }\r\n\r\n        //旋转角度不为0\r\n        if (labelStyle.rotation != 0) {\r\n            ctx.rotate(labelStyle.rotation);\r\n        }\r\n\r\n        // 碰撞检测\r\n        var textWidth =\r\n            ctx.measureText(labelStyle.text).width * labelStyle.scale;\r\n        var textHeight = labelStyle.defaultHeight * labelStyle.scale;\r\n        let minX, minY, maxX, maxY;\r\n\r\n        //https://www.runoob.com/tags/canvas-textalign.html\r\n        if (labelStyle.textAlign == \"center\") {\r\n            minX = x - textWidth / 2;\r\n            maxX = x + textWidth / 2;\r\n        } else if (\r\n            labelStyle.textAlign == \"start\" ||\r\n            labelStyle.textAlign == \"left\"\r\n        ) {\r\n            minX = x;\r\n            maxX = x + textWidth;\r\n        } else if (\r\n            labelStyle.textAlign == \"end\" ||\r\n            labelStyle.textAlign == \"right\"\r\n        ) {\r\n            minX = x - textWidth;\r\n            maxX = x;\r\n        } else {\r\n            console.error(\r\n                \"textAlign的值必须是start，end，left，center，right中的一个！\"\r\n            );\r\n        }\r\n\r\n        //https://www.runoob.com/tags/canvas-textBaseline.html\r\n        if (labelStyle.textBaseline == \"middle\") {\r\n            minY = y - textHeight / 2;\r\n            maxY = y + textHeight / 2;\r\n        } else if (\r\n            labelStyle.textBaseline == \"top\" ||\r\n            labelStyle.textBaseline == \"hanging\"\r\n        ) {\r\n            minY = y;\r\n            maxY = y + textHeight;\r\n        } else if (\r\n            labelStyle.textBaseline == \"bottom\" ||\r\n            labelStyle.textBaseline == \"alphabetic\"\r\n        ) {\r\n            minY = y - textHeight;\r\n            maxY = y;\r\n        } else {\r\n            console.error(\r\n                \"textBaseline的值必须是middle，top，hanging，bottom，alphabetic中的一个！\"\r\n            );\r\n        }\r\n\r\n        let textBounds = { minX, minY, maxX, maxY, layer };\r\n        if (\r\n            !(\r\n                labelStyle.collisionFlg == true &&\r\n                this._textBounds.collides(textBounds)\r\n            )\r\n        ) {\r\n            //绘制标注\r\n            ctx.strokeText(labelStyle.text, 0, 0);\r\n            ctx.fillText(labelStyle.text, 0, 0);\r\n            this._textBounds.insert(textBounds);\r\n        }\r\n\r\n        //还原画布样式\r\n        ctx.restore();\r\n    },\r\n    /**\r\n     * 执行侦听器\r\n     */\r\n    _executeListeners: function (event) {\r\n        if (!this._textBounds) return;\r\n        var me = this;\r\n        var ret = this.getTextByEvent(event);\r\n        if (ret && ret.length > 0) {\r\n            me._map._container.style.cursor = \"pointer\";\r\n            if (event.type === \"click\") {\r\n                me._onClickListeners.forEach(function (listener) {\r\n                    listener(event, ret);\r\n                });\r\n            }\r\n            if (event.type === \"mousemove\") {\r\n                me._onHoverListeners.forEach(function (listener) {\r\n                    listener(event, ret);\r\n                });\r\n            }\r\n            if (event.type === \"mousedown\") {\r\n                me._onMouseDownListeners.forEach(function (listener) {\r\n                    listener(event, ret);\r\n                });\r\n            }\r\n\r\n            if (event.type === \"mouseup\") {\r\n                me._onMouseUpListeners.forEach(function (listener) {\r\n                    listener(event, ret);\r\n                });\r\n            }\r\n        } else {\r\n            me._map._container.style.cursor = \"\";\r\n        }\r\n    },\r\n    /**\r\n     * 添加click侦听器\r\n     */\r\n    addOnClickListener: function (listener) {\r\n        this._onClickListeners.push(listener);\r\n    },\r\n\r\n    /**\r\n     * 添加hover侦听器\r\n     */\r\n    addOnHoverListener: function (listener) {\r\n        this._onHoverListeners.push(listener);\r\n    },\r\n\r\n    /**\r\n     * 添加mousedown侦听器\r\n     */\r\n    addOnMouseDownListener: function (listener) {\r\n        this._onMouseDownListeners.push(listener);\r\n    },\r\n\r\n    /**\r\n     * 添加mouseup侦听器\r\n     */\r\n    addOnMouseUpListener: function (listener) {\r\n        this._onMouseUpListeners.push(listener);\r\n    },\r\n    getTextByEvent(event){\r\n        var x = event.layerPoint.x;\r\n        var y = event.layerPoint.y;\r\n\r\n        var ret = this._textBounds.search({\r\n            minX: x,\r\n            minY: y,\r\n            maxX: x,\r\n            maxY: y,\r\n        });\r\n        return ret;\r\n    }\r\n}));\r\n\r\nexport var canvasLabel = (L.canvasLabel = function (options) {\r\n    return new L.CanvasLabel(options);\r\n});\r\n"],"names":[],"sourceRoot":""}